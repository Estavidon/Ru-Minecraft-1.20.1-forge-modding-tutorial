---
tags:
  - loot
  - tables
  - json
---
# Базовая структура

Таблицы лута для блоков хранятся по адресу **resources.data.ваш mod_id.loot_tables.blocks**. Также важно отметить, что все файлы внутри **blocks** должны иметь название, чётко соответствующее коду модифицируемого блока — иначе модификация не применится к нему.

Для начала работы создайте .json файл с названием в виде кода блока и перейдите в него.

Структура таблиц лута для обычных блоков выглядит следующим образом:
```json
{
	"type": "minecraft:block",
	"random_sequence": "myfirstmod:blocks/код блока",
	"pools": [
		{
			"rolls": 1.0,	
			"entries": [
				{
					"type": "minecraft:item",
					"name": код выпадающего предмета,
					*"conditions": [{}],
					*"functions": [{}]
				}
			]
		}
	]
}
```

!!! Звёздочкой * я отметил необязательные поля, но у вас этой звёздочки не должно быть ни в каком виде.

При таком раскладе (исключая поля со звёздочками) выпадет 1 предмет (чаще всего этот же блок), который вы указали (если конечно инструмент позволяет, а как указать инструмент, которым можно добыть блок вы можете прочитать [[Тип и уровень инструмента для добычи блока|тут]]).

Выглядит сложно — так оно и есть, но давайте по порядку.
Сразу обозначу 2 важные вещи: 
1) Поля могут располагаться в любом порядке — например в коде самого Minecraft мой пример выглядел бы так:
```json
{
	"type": "minecraft:block",
	"pools": [
		{
			"entries": [
				{
					"type": "minecraft:item",
					"name": код выпадающего предмета,
					*"conditions": [{}],
					*"functions": [{}]
				}
			],
			"rolls": 1.0	
		}
	],
	"random_sequence": "myfirstmod:blocks/код блока"
}
```
Но мне кажется что мой вариант более понятен и нагляден, поэтому я показал его.

2) JSON структура Minecraft очень гибкая, из-за чего одни и те же функции можно реализовать несколькими разными способами — поэтому не удивляйтесь если увидите в других источниках другие подходы к созданию таблиц лута. Я просто оценил свой вариант как самый удобный и наглядный, и если вы захотите использовать другие архитектурные решения то это нормально.

Итак, теперь разберём эту структуру по полочкам:
```json
"type": "minecraft:block",
"random_sequence": "myfirstmod:blocks/код блока"
```
Первая строчка указывает, что мы работаем с блоком, а не сундуком, к примеру.

Вторая строчка указывает на блок, для которого мы пишем таблицу лута. Это легаси поле, которое в теории можно убрать, но это иногда приводит к рассинхронизации партиклов при разрушении блока у разных игроков (никак не влияет на сам лут).

На этом чисто технические поля заканчиваются и начинается реально полезная нагрузка.
Для начала стоит рассказать про общую структуру таблиц лута.

Для начала поле 
```json
"pools": [{}]
```
Это массив возможных комбинаций дропа предметов с блока, и внутри этого массива лежат скрепляющие списки, которые являют собой конкретные пулы (далее пулы) предметов. При ломании блока обрабатываются все пулы, и если 2 разных пула сработают одновременно, то выпадут предметы из обоих пулов. Внутри пула лежит ещё 2 поля:

С первым всё просто — 
```json
"rolls": float
``` 
Это поле, указывающее на кол-во раз, которое просчитается дроп с данного пула — например если указать 2, то выпадет 2 предмета (в обычном случае).

Со вторым всё куда сложнее.
Далее вся структура таблицы лута состоит из 1 основного и 2 вспомогательных компонентов:
```json
{
	"entries": [{}],
	"conditions": [{}],
	"functions": [{}]
}
```

1) **entries** — содержит массив списков, содержащих информацию непосредственно о выпадающих предметах (далее — записи). Если сработает сразу 2 или более записи, то дроп даст 1 рандомная из них — регулировать шанс на конкретную запись можно при помощи поля
```json
"weight": int 
```
При этом чаще всего будет падать запись с самым большим "**weight**"
2) **conditions** — содержит условия для выполнения того или иного блока кода
3) **functions** — содержит модификаторы, такие как: количество выпадающих предметов (чаще всего), зачарования на них, их прочность.

Про последние 2 мы поговорим позже

Внутри записи в базовом случае существует 2 поля:
```json
"entries": [
	{
		"type": "minecraft:item",
		"name": код выпадающего предмета
	}
]
```

Первое поле "type" указывает на тип этой записи (в данной случае предмет).
Последующие поля зависят от типа записи, в данном случае "name" указывает на код выпадающего предмета.

Рассмотрим другой случай, отличный от базового:
```json
{
	"type": "minecraft:block",
	"random_sequence": "myfirstmod:blocks/block1",
	"pools": [
		{
			"rolls": 1.0,
			"entries": [
				{
					"type": "minecraft:alternatives",
					"children": [
						{
							"type": "minecraft:item",
							"name": "item1"
						},
						{
							"type": "minecraft:item",
							"name": "item2"
						}
					]
				}
			]
		}
	]
}
```
Эта запись похожа на базовую, но есть отличия.
Теперь вместо записи типа "minecraft:item" мы используем запись "minecraft:alternatives".
Далее мы создаём ключ "children", выполняющий роль "entries" и теперь мы можем добавить сколько угодно записей внутри одной.

Концептуально, мы создаём переходник, позволяющий добавлять несколько записей внутри одной, однако если в entries рандомно выбирается сработавшая запись из списка, то внутри "children" (далее дочерняя запись) выбирается чётко первая сработавшая запись. Зачем это нужно разберём чуть позже.

# Структура приоритетов лута

Теперь мы имеем чёткую структуру приоритетов лута:
- Если нужно чтобы падало и то, и другое — делаем новый **пул**
- Если нужно чтобы рандомно падало или то, или другое — делаем новую **запись**
- Если нужно чтобы если не падало одно, то падало другое, если не другое то третье и тд — делаем новую **дочернюю запись**

# Условия (conditions)

Далее мы поговорим о разрешающем параметре **conditions** — это массив записей **condition** где каждая такая запись возвращает либо 0 либо 1 (чаще всего с помощью predicate, однако об этом позже), а затем если **ХОТЬ 1** равен 0, то на его уровне блокируется **запись**, **дочерняя запись** или даже **пул**.
Для начала я покажу самый практический пример:
```json
{
	"type": "minecraft:block",
	"random_sequence": "myfirstmod:blocks/ore_block",
	"pools": [
		{
			"rolls": 1.0,
			"entries": [
				{
					"type": "minecraft:alternatives",
					"children": [
						{
							"type": "minecraft:item",
							"name": "ore_block",
							"conditions": [
								{
									"condition": "minecraft:match_tool",
									"predicate": {  
					                    "enchantments": [  
					                      {  
					                        "enchantment": "minecraft:silk_touch", 
					                        "levels": {  
					                          "min": 1  
					                        }  
					                    }  
									}
								}
							]
						},
						{
							"type": "minecraft:item",
							"name": "ore"
						}
					]
				}
			]
		}
	]
}
```
Добавилось очень много скобок, однако хоть это и выглядит страшно — понять это не так уж сложно.
Это стандартная схема для добавления варианта с шёлковым касанием в цепочку для руды.
Теперь если вскопать данный блок подходящим инструментом на шёлковое касание, то выпадет **ore_block**, а иначе **ore**. Это происходит так, поскольку дочерняя запись для **ore** находится ниже дочерней записи для **ore_block** — поэтому приоритетно будет попытка обработать первый дочерний элемент, и только если в conditions вернётся ложь, то будет обработан второй дочерний элемент.

В этой цепочке также довольно часто встречается поле **predicate** — это поле также возвращает 0 или 1, на основе каких-либо данных (в данном случае зачарования инструмента), но оно скорее проверяет что-то, тогда как **condition** чаще всего прикидывает шансы. **ДОПОЛНИТЬ** ^ ТУТ ВАЩЕ БРЕД

# Функции (functions)

Далее разберём поле **functions** — это поле нужно для регулирования характеристик выпадающих предметов (чаще всего именно их количество). Оно содержит в себе массив списков, в которых описывается модификаторы для выпадающих предметов (далее функции).

Вот пример работы функции:
```json
{
	"type": "minecraft:block",
	"random_sequence": "myfirstmod:blocks/код блока",
	"pools": [
		{
			"rolls": 1.0,	
			"entries": [
				{
					"type": "minecraft:item",
					"name": "код выпадающего предмета",
					"functions": [
						{
							"function": "minecraft:set_count",
							"count": 4
						}
					]
				}
			]
		}
	]
}
```
Теперь будет падать 4 предмета, а не 1 как обычно. Но это ещё не всё — в любые числовые значения внутри json файлов можно добавить разброс. Делается это подобным образом:
```json
"functions": [
	{
		"function": "minecraft:set_count",
		"count": {  
            "type": "minecraft:uniform",  
            "min": 1.0,  
            "max": 4.0  
	    } 
	}
]
```
Теперь будет падать рандомное количество предмета от 1 до 4.

Однако можно не только указать стандартное количество лута, но и модифицировать его.
Например уничтожить часть дропа при взрыве, или добавить при добыче киркой на удачу. Выглядело бы это примерно так:
```json
"functions": [
	{
		"function": "minecraft:set_count",
		"count": {  
            "type": "minecraft:uniform",  
            "min": 1.0,  
            "max": 4.0  
	    } 
	},
	{
		"function": "minecraft:explosion_decay"
	},
	{
		"function": "minecraft:apply_bonus",
        "enchantment": "minecraft:fortune",
        "formula": "minecraft:ore_drops"
	}
	
]
```
Теперь, если блок взорван — выпадет меньше предметов, чем при добыче киркой без удачи, а при добыче киркой на удачу выпадет больше (при этом насколько больше уже определено Minecraft, однако можно задать формулу самому **ДОПОЛНИТЬ**).

# Пример из ванильного Minecraft

Когда вы наконец изучили базовые аспекты этого непростого параграфа, вы можете посмотреть код реальной руды из Minecraft — лазуритовой руды:
```json
{  
  "type": "minecraft:block",  
  "random_sequence": "minecraft:blocks/lapis_ore", 
  "pools": [  
    {  
      "bonus_rolls": 0.0,
      "rolls": 1.0,  
      "entries": [  
        {  
          "type": "minecraft:alternatives",  
          "children": [  
            {  
              "type": "minecraft:item",  
              "name": "minecraft:lapis_ore", 
              "conditions": [  
                {  
                  "condition": "minecraft:match_tool",  
                  "predicate": {  
                    "enchantments": [  
                      {  
                        "enchantment": "minecraft:silk_touch",  
                        "levels": {  
                          "min": 1  
                        }  
                      }  
                    ]  
                  }  
                }  
              ]  
            },  
            {  
              "type": "minecraft:item",  
              "name": "minecraft:lapis_lazuli",
              "functions": [  
                {  
                  "add": false,  
                  "count": {  
                    "type": "minecraft:uniform",  
                    "max": 9.0,  
                    "min": 4.0  
                  },  
                  "function": "minecraft:set_count"  
                },  
                {  
                  "enchantment": "minecraft:fortune",  
                  "formula": "minecraft:ore_drops",  
                  "function": "minecraft:apply_bonus"  
                },  
                {  
                  "function": "minecraft:explosion_decay"  
                }  
              ]  
            }  
          ]  
        }  
      ]    
    }  
  ]  
}
```

Здесь уже комбинируются все знания, полученные из этого гайда, можно заметить что здесь один пул, и одна запись для дропа предметов, однако 2 дочерние записи — одна для сценария с шёлковым касанием, обрабатывается приоритетно (поскольку выше в коде), и только если шёлкового касания нет (проверяется через **conditions**) происходит обработка второго дочернего элемента.
Во втором дочернем элементе уже обрабатываются все остальные сценарии — тут указано базовое количество дропа (4-9 предметов), функция для умножения количества лута в зависимости от уровня удачи и функция для уменьшения кол-ва дропа если блок взорван.

# Заключение

Это довольно сложная тема, и я настоятельно рекомендую поэкспериментировать.

В любом случае, если вы не хотите во всём этом разбираться, вы можете просто подставить значения в начальный пример (если вам нужно просто чтобы, например, выпадал тот же блок), или в пример лазурита (если вы хотите добавить свою руду).

---
Назад к [[00 Hub]]
