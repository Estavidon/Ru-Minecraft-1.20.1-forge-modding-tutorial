Этот раздел уже не подходит для людей плохо разбирающихся в программировании - если вы хотите добавить для предмета уникальную механику, то так или иначе придётся углубится в основы программирования и ООП на java. 

Однако если вы уже разбираетесь в программировании - поздравляю! вы наконец дошли до раздела, где вы впервые сможете встроить свою логику в игру.

# Общее устройство
для создания своих продвинутых предметов в данном разделе мы будем использовать **наследование** от базового класса Item (или любого другого класса из ванильного майнкрафта/зависимых модов), и **переопределение методов** в наследуемом классе.

# Перейдём ближе к практике
Создайте файл класса java в пакете java... .item.custom - при этом название созданного класса может быть произвольным (так вы назовёте свой подкласс предмета).
теперь зайдите внутрь и организуйте наследование от класса **Item**, и внутри конструктора передайте значения в конструктор родительского класса - в java это происходит следующим образом:
```java
public class ThunderItem extends Item {  // наследуем от класса Item  
    public ThunderItem(Properties pProperties) {  // создаём конструктор  
        super(pProperties); // передаём значения в родительский класс  
    }  
  
  
}
```
### ⚠️ Рекомендация
если у вас проблемы с пониманием даже такого кода, настоятельно рекомендую получше изучить java, так как в этом и некоторых других сложных разделах она просто необходима
### ✔️ Если у вас не возникло проблем, то двигаемся дальше:

теперь у вас фактически уже готов свой подкласс предмета, однако он, фактически, абсолютно ничего не делает, просто перенаправляя всё в родительский конструктор. 
сейчас это просто обычный предмет, а добавлять функционал для него мы будем при помощи **переопределения** его функций.

### ❔Что мы собираемся сделать

Чтобы было понятнее, что и зачем я делаю, я сразу обозначу будущий функционал нашего предмета: 
- при ударе по мобу он будет вызывать на него молнию
- при нажатии правой кнопкой мыши он будет ломать под игроком столько блоков, сколько у него здоровья (бесполезно в игре, зато наглядно в моде). 

### Начнём реализовывать этот функционал:

Для начала - у класса **Item** есть **3** основных метода для считывания нажатий:
1) **use** - нажатие правой кнопкой мыши **НЕ** по блоку
2) **useOn** - нажатие правой кнопкой мыши по блоку
3) **hurtEnemy** - удар по мобу/нажатие левой кнопкой мыши.

сейчас нам нужны именно они.
чтобы что-то переопределить нам нужно начать писать название нужной функции под/над конструктором и IDE, скорее всего, само предложит нужную функцию. 
#### Создание конструктора и функции

Теперь, в первую очередь, мы добавим функцию для считывания удара по мобу, после чего ваш код должен выглядеть примерно так:
```java
public class ThunderItem extends Item {  // наследуем от класса Item  
    public ThunderItem(Properties pProperties) {  // создаём конструктор  
        super(pProperties); // передаём значения в родительский класс  
    }  
  
    @Override  
    public boolean hurtEnemy(ItemStack pStack, LivingEntity pTarget, LivingEntity pAttacker) {  
          return super.hurtEnemy(pStack, pTarget, pAttacker); // возвращаем значения в наследуемый метод, повторяя его обычную функциональность
    }  
}
```

при этом в родительском классе **Item** эта функция ничего не делает:
![[Pasted image 20260202114416.png]]
это означает что вы можете либо оставить код как есть для структурной целостности, либо сделать так для простоты понимания:
```java
public class ThunderItem extends Item {  // наследуем от класса Item  
    public ThunderItem(Properties pProperties) {  // создаём конструктор  
        super(pProperties); // передаём значения в родительский класс  
    }  
  
    @Override  
    public boolean hurtEnemy(ItemStack pStack, LivingEntity pTarget, LivingEntity pAttacker) {  
          return false;
    }  
}
```
#### Взаимодействие с миром через **Level**

Объекты класса **Level** содержат всю информацию о мире, а так-же предоставляет методы для взаимодействия с ним. 
получить этот объект можно из передаваемых сущностей или контекста. чаще всего методы для получения выглядят как **level()** или **getLevel()**
чаще всего информация о мире **получается** через методы типа get...
а редактируется через методы set... / add...

#### Добавим функционал в hurtEnemy

Теперь создадим сущность **LightningBolt** по этому гайду: [[Создание базовых мобов]], а затем получите **Level** и добавьте созданную сущность в мир через метод **addFreshEntity()**.

По итогу должно получится что-то такое:
```java
@Override  
public boolean hurtEnemy(ItemStack pStack, LivingEntity pTarget, LivingEntity pAttacker) {  
    LightningBolt lightningBolt = new LightningBolt(EntityType.LIGHTNING_BOLT, pTarget.level());  
    lightningBolt.setDamage(200);  
    lightningBolt.setPos(pTarget.getPosition(0));  
    pAttacker.level().addFreshEntity(lightningBolt);  
    return false;  
}
```

Всё! теперь ваш предмет при ударе по мобу будет вызывать очень мощную молнию (200 урона).
#### Добавим функционал в use

Аналогичным образом переопределите метод "use". должно получится примерно так:
```java
@Override  
public InteractionResultHolder<ItemStack> use(Level pLevel, Player pPlayer, InteractionHand pUsedHand) {  
    return super.use(pLevel, pPlayer, pUsedHand);  
}
```

Здесь всё чуть сложнее с возвращаемым значением - лучше оставьте super метод.

