# Создание папки и класса

Итак, для создания блоков для начала создайте новую директорию в одной папке с главным файлом мода и назовите её **block**.

Далее перейдите в созданную директорию и создайте там файл класса java с названием **ModBlocks**, а затем откройте его.

# Создание базовой структуры

В нём как обычно нужно создать стыковочную среду. Для этого напишите вот такой код:
```java
import net.minecraft.world.item.BlockItem;  
import net.minecraft.world.item.Item;  
import net.minecraft.world.level.block.Block;  
import net.minecraft.world.level.block.Blocks;  
import net.minecraft.world.level.block.state.BlockBehaviour;  
import net.minecraftforge.eventbus.api.IEventBus;  
import net.minecraftforge.registries.DeferredRegister;  
import net.minecraftforge.registries.ForgeRegistries;  
import net.minecraftforge.registries.RegistryObject;  
  
import java.util.function.Supplier;  
  
public class ModBlocks {  
    public static final DeferredRegister<Block> BLOCKS =  
            DeferredRegister.create(ForgeRegistries.BLOCKS, MyFirstMod.MOD_ID);  
  
  
  
	public static void register(IEventBus eventBus) {  
        BLOCKS.register(eventBus);  
    }  
}
```
! Не забудьте заменить **MyFirstMod** на название вашего главного класса мода.

А затем зайдите в главный файл мода и добавьте в конструктор вот такую строчку:
```java
ModBlocks.register(modEventBus);
```

После этого можно начать создавать блок.
Для создания блока в игре нужно создать сам блок и предмет блока.

# Создание блока

Для начала создадим блок:
```java
public static final RegistryObject<Block> BLOCK1 = BLOCKS.register("block1",  
        () -> new Block(BlockBehaviour.Properties.copy(Blocks.DIAMOND_BLOCK)));
```

Здесь мы первым аргументом передаём именной код, а потом поставщик с конструктором блока.
На моменте **Properties** можно выбрать 2 метода: .**copy** и .**of**. Они отличаются тем, что первый **копирует** характеристики уже существующего блока в игре и выборочно изменять их. 
К примеру, если вам нужно изменить базовые звуки блока, то это выглядело бы так:
```java
public static final RegistryObject<Block> BLOCK1 = BLOCKS.register("block1",  
        () -> new Block(BlockBehaviour.Properties.copy(Blocks.DIAMOND_BLOCK).sound(SoundType.AMETHYST)));
```

.**of** же в свою очередь заставляет вас полностью вписывать все характеристики блока **с 0**, что чаще всего не удобно и не нужно.

# Создание предмета блока

После того как мы создали объект самого блока, нам нужно создать объект **предмета блока**: 
```java
public static final RegistryObject<BlockItem> BLOCK1_ITEM = ModItems.ITEMS.register("block1",  
        () -> new BlockItem(BLOCK1.get(), new Item.Properties()));
```

Здесь мы первым аргументом снова указываем именной код предмета, однако для избежания путаницы здесь необходимо указывать то же самое что и для блока.
Вторым аргументом мы передаём поставщик конструктора **предмета блока**.
В этот конструктор первым аргументом нам необходимо указать на объект блока, который мы создали до этого, а вторым аргументом создать новые свойства предмета.

Теперь этот блок существует в игре, хоть пока и без модели и текстуры.

# Упрощение создания блоков

Несмотря на то, что этот вариант создания блока рабочий, он заставляет вас каждый раз создавать ненужную конструкцию предмета блока, которая всё равно почти всё копирует из самого блока. Для того чтобы этого избежать и не писать ненужный код, можно добавить в этот класс 2 небольших метода:
```java
private static <T extends Block> RegistryObject<T> registryBlock(String name, Supplier<T> block) {  
    RegistryObject<T> toReturn = BLOCKS.register(name, block);  
    registerBlockItem(name, toReturn);  
    return toReturn;  
}  
  
private static <T extends Block>RegistryObject<Item> registerBlockItem(String name, RegistryObject<T> block) {  
    return ModItems.ITEMS.register(name, () -> new BlockItem(block.get(), new Item.Properties()));  
}
```

Верхний метод принимает первым аргументом именной код, а вторым поставщик объекта **блока**.
Далее в переменную **toReturn** возвращается готовый объект класса блока, после чего без присваивания вызывается нижний метод, куда передаётся именной код блока и готовый объект блока. В конце возвращается созданный объект блока.

Нижний же метод как раз создаёт объект **предмета блока** и возвращает его.

В верхнем методе значение **предмета блока** не присваивается потому, что объект **блока** может использоваться как предмет, и это позволяет почти в 100% случаев не использовать вовсе объект **предмета блока**. Более подробно я раскрою это чуть дальше.

После добавления этих 2 методов создание и **блока**, и **предмета блока** происходит почти в 1 строку:
```java
public static final RegistryObject<Block> BLOCK1 = registryBlock("block1",  
        () -> new Block(BlockBehaviour.Properties.copy(Blocks.DIAMOND_BLOCK)));
```

Как можно заметить, это куда быстрее и проще — без лишнего кода и затрат времени.

# Локализация блока

Теперь, после того как мы добавили блок и предмет блока в игру, мы можем приступить к его модели, текстуре и локализации.

Начнём с самого простого — добавим читабельное для пользователя название.
Для этого перейдите в файл локализации (если у вас его нет то создайте по этому [[Локализация|гайду]]) и создайте пару ключ-значение в формате - "block.ваш mod_id.код блока". В случае этого гайда это выглядит так:
```json
"block.myfirstmod.block1" : "Блок 1"
```

Тут можно заметить именно то, о чём я говорил раньше — мы используем объект **блока**, но при этом добавляем локализацию именно для **предмета блока**, так как они связываются ещё при инициализации.

# Создание модели блока

Далее нам необходимо добавить модель для блока. Для этого перейдите в файл **blockstates** в папке **resources**. После чего создайте там файл с названием в формате **код блока.json** (в этом гайде block1.json) вот такую структуру:
```json
{  
  "variants" : {  
    "" : {  
      "model" : "myfirstmod:block/block1"  
    }  
  }  
}
```
Как значение в ключ **model** передайте строку в формате - "ваш mod_id:block/код блока". В случае этого гайда — как в примере выше.
**ДОРАБОТАТЬ!!!!**
Честно говоря я не знаю почему образуется именно такая структура, необходимо **ДОПОЛНИТЬ** позже.

# Создание текстуры блока

После того как мы добавили свойства объёма блоку, нам необходимо также создать для него текстуры. Для этого перейдите в папку models.block и создайте там файл .json с названием в соответствии с кодом блока, по аналогии с ранее созданным файлом свойств. После этого перейдите в этот файл и создайте там вот такую структуру:
```json
{  
  "parent" : "minecraft:block/cube_all",  
  "textures" : {  
    "all" : "myfirstmod:block/block1_picture"  
  }  
}
```
В ключ **all** как значение необходимо указать строку в формате - "ваш mod_id:block/название изображения для текстуры".

Затем просто добавьте ваше изображение **block1_picture.png** в папку textures.block.

# Создание модели предмета блока

Теперь создадим модель для **предмета блока** — перейдите в папку models.item и создайте там файл с аналогичным предыдущему названием (в случае этого гайда block1.json). Затем создайте там вот такую простую структуру:
```json
{  
  "parent" : "myfirstmod:block/potyga_block"  
}
```
Таким образом, мы наследуем текстуру и модель от родителя, получая стандартный блок в инвентаре игрока, как и у всех ванильных блоков кубической формы.

# Заключение

Теперь этот блок добавлен в игру и имеет свой предмет, через который его можно разместить в мире. Теперь вы можете добавить его во вкладку в творческом режиме по этому [[Создание вкладки в креативе|гайду]] — при этом вы можете использовать для добавления как объект **блока**, так и объект **предмета блока**.